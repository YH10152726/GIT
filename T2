Option Explicit

' ====================================================================================
'
' ■■■ 全ての処理を行う、単独のマクロ (メッセージボックス削除版) ■■■
'
'       ボタンにはこの「OrganizeProcessSheet」を登録してください。
'
' ====================================================================================
Sub OrganizeProcessSheet()
    ' --- 処理開始時の設定 ---
    Dim startTime As Double
    startTime = Timer
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    On Error GoTo ErrorHandler

    ' --- 定数 ---
    Const SHEET_NAME As String = "工程表"
    Const COL_Y As String = "Y"
    Const COL_AG As String = "AG"
    Const HEADER_ROWS As Long = 1 ' ヘッダーの行数

    ' --- 変数 ---
    Dim ws As Worksheet
    Dim sourceData As Variant
    Dim parentItems As Object
    Dim orphanData As Object
    Dim lastRow As Long, lastCol As Long
    Dim dataStartRow As Long
    Dim i As Long, j As Long
    Dim pKey As Variant, cKey As Variant, item As Variant

    ' --- 1. データの読み込み ---
    On Error Resume Next
    Set ws = ThisWorkbook.Sheets(SHEET_NAME)
    If ws Is Nothing Then
        ' エラーメッセージは残す
        MsgBox "シート「" & SHEET_NAME & "」が見つかりません。", vbCritical
        GoTo Finally
    End If
    On Error GoTo ErrorHandler

    If ws.UsedRange.Rows.Count <= HEADER_ROWS Then GoTo Finally ' データがなければ終了
    
    lastRow = ws.UsedRange.Row + ws.UsedRange.Rows.Count - 1
    lastCol = ws.UsedRange.Column + ws.UsedRange.Columns.Count - 1
    dataStartRow = HEADER_ROWS + 1 ' データは2行目から
    
    sourceData = ws.Range(ws.Cells(dataStartRow, "A"), ws.Cells(lastRow, lastCol)).Value
    
    ' --- 2. メモリ上でデータのグループ分けと親子関係の整理 ---
    Set parentItems = CreateObject("Scripting.Dictionary")
    Set orphanData = CreateObject("Scripting.Dictionary")
    
    Dim regExY As Object, regExAG As Object
    Set regExY = CreateObject("VBScript.RegExp")
    regExY.pattern = "(\d+)と?同時|同時(\d+)"
    Set regExAG = CreateObject("VBScript.RegExp")
    regExAG.pattern = "^(\d+)"

    Dim yColNum As Long, agColNum As Long
    yColNum = ws.Range(COL_Y & "1").Column
    agColNum = ws.Range(COL_AG & "1").Column
    
    Dim currentBlockOwnerKey As String
    currentBlockOwnerKey = ""

    For i = 1 To UBound(sourceData, 1)
        Dim yVal As String, agVal As String
        yVal = Trim(CStr(sourceData(i, yColNum - (ws.UsedRange.Column - 1))))
        agVal = Trim(CStr(sourceData(i, agColNum - (ws.UsedRange.Column - 1))))
        
        Dim isParent As Boolean, isChild As Boolean, parentKeyStr As String
        isParent = regExAG.Test(agVal) And Not regExY.Test(yVal)
        isChild = regExAG.Test(agVal) And regExY.Test(yVal)
        
        Dim rowData() As Variant
        ReDim rowData(1 To UBound(sourceData, 2))
        For j = 1 To UBound(sourceData, 2)
            rowData(j) = sourceData(i, j)
        Next j

        If isParent Then
            parentKeyStr = regExAG.Execute(agVal)(0).SubMatches(0)
            currentBlockOwnerKey = parentKeyStr
            
            If Not parentItems.Exists(parentKeyStr) Then
                Set parentItems(parentKeyStr) = CreateObject("Scripting.Dictionary")
                Set parentItems(parentKeyStr)("rows") = CreateObject("Scripting.Dictionary")
                Set parentItems(parentKeyStr)("children") = CreateObject("Scripting.Dictionary")
            End If
            parentItems(parentKeyStr)("rows").Add parentItems(parentKeyStr)("rows").Count, rowData

        ElseIf isChild Then
            Dim matches As Object
            Set matches = regExY.Execute(yVal)
            If matches.Count > 0 Then
                parentKeyStr = IIf(matches(0).SubMatches(0) <> "", matches(0).SubMatches(0), matches(0).SubMatches(1))
            Else
                parentKeyStr = ""
            End If
            
            currentBlockOwnerKey = regExAG.Execute(agVal)(0).SubMatches(0)

            If parentKeyStr <> "" And parentItems.Exists(parentKeyStr) Then
                Dim childKeyAsLong As Long
                childKeyAsLong = CLng(currentBlockOwnerKey)
                
                Dim childrenDict As Object
                Set childrenDict = parentItems(parentKeyStr)("children")

                If Not childrenDict.Exists(childKeyAsLong) Then
                     Set childrenDict(childKeyAsLong) = CreateObject("Scripting.Dictionary")
                     childrenDict(childKeyAsLong).Add "key", childKeyAsLong
                     Set childrenDict(childKeyAsLong)("rows") = CreateObject("Scripting.Dictionary")
                End If
                childrenDict(childKeyAsLong)("rows").Add childrenDict(childKeyAsLong)("rows").Count, rowData
            Else
                orphanData.Add orphanData.Count, rowData
            End If
            
        Else ' ヘッダーではない行
            If currentBlockOwnerKey <> "" Then
                 Dim found As Boolean: found = False
                 For Each pKey In parentItems.Keys
                    If CStr(pKey) = currentBlockOwnerKey Then
                        parentItems(pKey)("rows").Add parentItems(pKey)("rows").Count, rowData
                        found = True: Exit For
                    Else
                        On Error Resume Next
       
                        childKeyAsLong = 0
                        childKeyAsLong = CLng(currentBlockOwnerKey)
                        If Err.Number = 0 Then
                            If parentItems(pKey)("children").Exists(childKeyAsLong) Then
                                parentItems(pKey)("children")(childKeyAsLong)("rows").Add parentItems(pKey)("children")(childKeyAsLong)("rows").Count, rowData
                                found = True: Exit For
                            End If
                        End If
                        On Error GoTo ErrorHandler
                    End If
                 Next pKey
                 If Not found Then orphanData.Add orphanData.Count, rowData
            Else
                 orphanData.Add orphanData.Count, rowData
            End If
        End If
    Next i
    
    ' --- 3. メモリ上で子部品を品番順に並べ替え ---
    ' (Dictionaryのキーでソートするため、このセクションでの明示的な処理は不要)
    
    ' --- 4. 整理・並べ替え済みのデータをシートに書き戻す ---
    ws.Range(ws.Cells(dataStartRow, "A"), ws.Cells(lastRow, lastCol)).ClearContents
    
    Dim outputRow As Long
    outputRow = dataStartRow
    
    Dim parentKeys As Variant, childKeys As Variant
    parentKeys = parentItems.Keys
    Call BubbleSort(parentKeys)

    For Each pKey In parentKeys
        For Each item In parentItems(pKey)("rows").Items
            ws.Range(ws.Cells(outputRow, 1), ws.Cells(outputRow, UBound(item, 1))).Value = Application.Transpose(Application.Transpose(item))
            outputRow = outputRow + 1
        Next item
        
        childKeys = parentItems(pKey)("children").Keys
        Call BubbleSort(childKeys)
        
        For Each cKey In childKeys
            Dim childRows As Object
            Set childRows = parentItems(pKey)("children")(cKey)("rows")
            For Each item In childRows.Items
                 ws.Range(ws.Cells(outputRow, 1), ws.Cells(outputRow, UBound(item, 1))).Value = Application.Transpose(Application.Transpose(item))
                 outputRow = outputRow + 1
            Next item
        Next cKey
    Next pKey
    
    For Each item In orphanData.Items
        ws.Range(ws.Cells(outputRow, 1), ws.Cells(outputRow, UBound(item, 1))).Value = Application.Transpose(Application.Transpose(item))
        outputRow = outputRow + 1
    Next item

    ' --- 完了メッセージを削除 ---
    ' MsgBox "全ての整頓処理が完了しました。", vbInformation

Finally:
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
    Debug.Print "全処理時間: " & Format(Timer - startTime, "0.00") & "秒"
    Set ws = Nothing
    Set parentItems = Nothing
    Set orphanData = Nothing
    Set regExAG = Nothing
    Set regExY = Nothing
    Exit Sub

ErrorHandler:
    MsgBox "処理中にエラーが発生しました。" & vbCrLf & _
           "エラー番号: " & Err.Number & vbCrLf & _
           "エラー内容: " & Err.Description, vbCritical
    Resume Finally
End Sub

' --- 配列をソートするための補助プロシージャ ---
Private Sub BubbleSort(ByRef arr As Variant)
    Dim i As Long, j As Long
    Dim temp As Variant
    If Not IsArray(arr) Then Exit Sub
    If UBound(arr) < LBound(arr) Then Exit Sub

    For i = LBound(arr) To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If CVar(arr(i)) > CVar(arr(j)) Then
                temp = arr(j)
                arr(j) = arr(i)
                arr(i) = temp
            End If
        Next j
    Next i
End Sub

